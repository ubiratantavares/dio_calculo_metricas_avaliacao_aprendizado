# -*- coding: utf-8 -*-
"""matriz de confusao.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RKHFIT56TeVANyCGMlAirJu466SQg50z
"""

# Instalando o TensorFlow
!pip install -q tensorflow-gpu==2.10.0

# Importando bibliotecas
from tensorflow.keras import datasets, layers, models, callbacks
import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import io
import os

# Verificando a versão do TensorFlow
print("Versão do TensorFlow:", tf.__version__)

# Carregando o dataset MNIST
(train_images, train_labels), (test_images, test_labels) = datasets.mnist.load_data()

# Pré-processando dos dados
train_images = train_images.reshape((60000, 28, 28, 1)).astype('float32') / 255.0
test_images = test_images.reshape((10000, 28, 28, 1)).astype('float32') / 255.0

# Classes do modelo
classes=[0,1,2,3,4,5,6,7,8,9]

# Construindo o modelo
model = models.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.Flatten(),
    layers.Dense(64, activation='relu'),
    layers.Dense(10, activation='softmax')
])

# Compilando o modlelo
model.compile(optimizer='adam',
                         loss='sparse_categorical_crossentropy',
                         metrics=['accuracy'])

# Treinando o modelo
model.fit(train_images, train_labels, epochs=5, validation_data=(test_images, test_labels))

# Gerando as previsões das classes
y_pred = np.argmax(model.predict(test_images), axis=-1)

# Gerando a matriz de confusão
con_mat = tf.math.confusion_matrix(labels=test_labels, predictions=y_pred).numpy()
print(con_mat)

con_mat_norm = np.around(con_mat.astype('float') / con_mat.sum(axis=1)[:, np.newaxis], decimals=2)

con_mat_df = pd.DataFrame(con_mat_norm, index=classes, columns=classes)

print(con_mat_df)

# Visualizando a matriz de confusão
plt.figure(figsize=(8, 8))
sns.heatmap(con_mat_df, annot=True, cmap=plt.cm.Blues)
plt.tight_layout()
plt.ylabel('True label')
plt.xlabel('Predicted label')
plt.show()

import numpy as np

class ClassificationMetrics:
    def __init__(self, confusion_matrix):
        """
        Inicializa a classe com a matriz de confusão.
        :param confusion_matrix: Matriz de confusão (numpy array)
        """
        self.confusion_matrix = confusion_matrix
        self.VP = np.diag(confusion_matrix)  # Verdadeiros positivos
        self.FP = confusion_matrix.sum(axis=0) - self.VP  # Falsos positivos
        self.FN = confusion_matrix.sum(axis=1) - self.VP  # Falsos negativos
        self.VN = confusion_matrix.sum() - (self.VP + self.FP + self.FN)  # Verdadeiros negativos

    def sensitivity(self):
        """
        Calcula a sensibilidade (recall) para cada classe.
        :return: Sensibilidade por classe (array)
        """
        return np.round(self.VP / (self.VP + self.FN), decimals=2)

    def specificity(self):
        """
        Calcula a especificidade para cada classe.
        :return: Especificidade por classe (array)
        """
        return np.round(self.VN / (self.VN + self.FP), decimals=2)

    def accuracy(self):
        """
        Calcula a acurácia geral.
        :return: Acurácia (float)
        """
        total_correct = self.VP.sum()
        total_elements = self.confusion_matrix.sum()
        return np.round(total_correct / total_elements, decimals=2)

    def precision(self):
        """
        Calcula a precisão para cada classe.
        :return: Precisão por classe (array)
        """
        return np.round(self.VP / (self.VP + self.FP), decimals=2)

    def f_score(self):
        """
        Calcula o F-score para cada classe.
        :return: F-score por classe (array)
        """
        precision = self.precision()
        sensitivity = self.sensitivity()
        return np.round(2 * (precision * sensitivity) / (precision + sensitivity), decimals=2)

    def report(self):
        """
        Gera um relatório com todas as métricas.
        :return: Dicionário contendo as métricas por classe
        """
        return {
            "Sensitivity": self.sensitivity(),
            "Specificity": self.specificity(),
            "Accuracy": self.accuracy(),
            "Precision": self.precision(),
            "F-Score": self.f_score(),
        }

# Criando a  instância da classe ClassificationMetrics
metrics = ClassificationMetrics(con_mat)

# Obtendo as métricas
report = metrics.report()

# Exibindo relatório das métricas
print("Relatório de Métricas:")
for metric, values in report.items():
    if isinstance(values, np.ndarray):
        print(f"{metric}: {values.tolist()}")
    else:
        print(f"{metric}: {values}")

# Callback para TensorBoard
logdir = 'logs/images'

os.makedirs(logdir, exist_ok=True)

file_writer = tf.summary.create_file_writer(logdir)

def log_confusion_matrix(epoch, logs):
    test_pred = np.argmax(model.predict(test_images), axis=-1)

    con_mat = tf.math.confusion_matrix(labels=test_labels, predictions=test_pred).numpy()
    con_mat_norm = np.around(con_mat.astype('float') / con_mat.sum(axis=1)[:, np.newaxis], decimals=2)

    con_mat_df = pd.DataFrame(con_mat_norm, index=classes, columns=classes)

    figure = plt.figure(figsize=(8, 8))
    sns.heatmap(con_mat_df, annot=True, cmap=plt.cm.Blues)
    plt.tight_layout()
    plt.ylabel('True label')
    plt.xlabel('Predicted label')

    buf = io.BytesIO()
    plt.savefig(buf, format='png')
    plt.close(figure)
    buf.seek(0)
    image = tf.image.decode_png(buf.getvalue(), channels=4)
    image = tf.expand_dims(image, 0)

    with file_writer.as_default():
        tf.summary.image("Confusion Matrix", image, step=epoch)

tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=logdir)
cm_callback = callbacks.LambdaCallback(on_epoch_end=log_confusion_matrix)

# Treinando modelo com callback
model.fit(train_images, train_labels, epochs=5, verbose=0,
          validation_data=(test_images, test_labels),
          callbacks=[tensorboard_callback, cm_callback])

# Commented out IPython magic to ensure Python compatibility.
# Para iniciar o TensorBoard, execute o comando abaixo no terminal:
# %tensorboard --logdir logs/images